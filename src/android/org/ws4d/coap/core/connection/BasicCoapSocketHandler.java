/* Copyright 2011 University of Rostock
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *****************************************************************************/

package org.ws4d.coap.core.connection;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.MulticastSocket;
import java.net.NetworkInterface;
import java.nio.ByteBuffer;
import java.nio.channels.DatagramChannel;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.PriorityBlockingQueue;

import org.ws4d.coap.core.CoapClient;
import org.ws4d.coap.core.CoapConstants;
import org.ws4d.coap.core.connection.api.CoapChannel;
import org.ws4d.coap.core.connection.api.CoapChannelManager;
import org.ws4d.coap.core.connection.api.CoapClientChannel;
import org.ws4d.coap.core.connection.api.CoapServerChannel;
import org.ws4d.coap.core.connection.api.CoapSocketHandler;
import org.ws4d.coap.core.enumerations.CoapPacketType;
import org.ws4d.coap.core.messages.AbstractCoapMessage;
import org.ws4d.coap.core.messages.CoapEmptyMessage;
import org.ws4d.coap.core.messages.api.CoapMessage;
import org.ws4d.coap.core.tools.TimeoutHashMap;

/**
 * @author Christian Lerche <christian.lerche@uni-rostock.de>
 * @author Nico Laum <nico.laum@uni-rostock.de>
 */

public class BasicCoapSocketHandler implements CoapSocketHandler {
	/*
	 * the socket handler has its own logger 
	 */
	private static final int POLLING_INTERVALL = 10000;
	
	private int localPort;

	private WorkerThread workerThread = null;
	// TODO can be removed MC receive thread can also handle unicast messages
	private ReceiveThread receiveThread = null;
	private ReceiveThread receiveMCThread = null;
	private Map<ChannelKey, CoapClientChannel> clientChannels = new HashMap<ChannelKey, CoapClientChannel>();
	private Map<ChannelKey, CoapServerChannel> serverChannels = new HashMap<ChannelKey, CoapServerChannel>();

	private CoapChannelManager channelManager = null;
	private DatagramChannel dgramChannel = null;
	private MulticastSocket dgramSocket = null;

	/** contains all received message keys of a remote (message id generated by the remote) to detect duplications */
	private TimeoutHashMap<MessageKey, Boolean> duplicateRemoteMap = new TimeoutHashMap<MessageKey, Boolean>(CoapConstants.ACK_RST_RETRANS_TIMEOUT_MS);
	
	/** contains all received message keys of the host (message id generated by the host) to detect duplications */
	private TimeoutHashMap<Integer, Boolean> duplicateHostMap = new TimeoutHashMap<Integer, Boolean>(CoapConstants.ACK_RST_RETRANS_TIMEOUT_MS);
	
	/** contains all messages that (possibly) needs to be retransmitted (ACK, RST) */
	private TimeoutHashMap<MessageKey, CoapMessage> retransMsgMap = new TimeoutHashMap<MessageKey, CoapMessage>(CoapConstants.ACK_RST_RETRANS_TIMEOUT_MS);
	
	/** contains all messages that are not confirmed yet (CON), MessageID is always generated by Host and therefore unique */
	private TimeoutHashMap<Integer, CoapMessage> timeoutConMsgMap = new TimeoutHashMap<Integer, CoapMessage>(CoapConstants.ACK_RST_RETRANS_TIMEOUT_MS);
	
	/** this queue handles the timeout objects in the right order */
	private PriorityBlockingQueue<TimeoutObject<Integer>> timeoutQueue = new PriorityBlockingQueue<TimeoutObject<Integer>>();

	public BasicCoapSocketHandler(CoapChannelManager channelManager, int port) throws IOException {
		this.channelManager = channelManager;

		Enumeration<NetworkInterface> Interfaces = NetworkInterface.getNetworkInterfaces();
		NetworkInterface NetworkAdapter = null;
		
		while (Interfaces.hasMoreElements()) {
			NetworkAdapter = Interfaces.nextElement();
			if (NetworkAdapter.isUp() && !NetworkAdapter.isLoopback()) {
				break;
			}
		}

		this.dgramChannel = DatagramChannel.open();
		this.dgramChannel.socket().setReuseAddress(true);
		this.dgramChannel.socket().setReuseAddress(true);
		this.dgramChannel.socket().bind(new InetSocketAddress(port));

		this.localPort = this.dgramChannel.socket().getLocalPort();
		this.dgramChannel.configureBlocking(false);

		this.dgramSocket = new MulticastSocket(port);
		this.dgramSocket.setReuseAddress(true);
		this.dgramSocket.setNetworkInterface(NetworkAdapter);
		this.dgramSocket.setSoTimeout(0);
		this.dgramSocket.setReceiveBufferSize(CoapConstants.RECEIVE_BUFFER_SIZE);

		try{
		this.dgramSocket.joinGroup(InetAddress.getByName(CoapConstants.COAP_ALL_NODES_IPV6_LL_MC_ADDR));
		} catch(Exception e1){
		}
		try{
		this.dgramSocket.joinGroup(InetAddress.getByName(CoapConstants.COAP_ALL_NODES_IPV6_SL_MC_ADDR));
		} catch(Exception e1){
		}
		try{
		this.dgramSocket.joinGroup(InetAddress.getByName(CoapConstants.COAP_ALL_NODES_IPV4_MC_ADDR));
		} catch(Exception e1){
		}
		this.workerThread = new WorkerThread();
		this.workerThread.start();

		this.receiveThread = new ReceiveThread(false);
		this.receiveThread.start();

		this.receiveMCThread = new ReceiveThread(true);
		this.receiveMCThread.start();
	}
	
	DatagramChannel getDatagramChannel(){
		return this.dgramChannel;
	}
	
	MulticastSocket getDatagramSocket(){
		return this.dgramSocket;
	}
	
	Map<Integer, Boolean> getDuplicateHostMap(){
		return this.duplicateHostMap;
	}

	Map<Integer, CoapMessage> getTimeoutConMsgMap(){
		return this.timeoutConMsgMap;
	}
	
	Map<MessageKey, CoapMessage> getRetransMsgMap(){
		return this.retransMsgMap;
	}
	
	PriorityBlockingQueue<TimeoutObject<Integer>> getTimeoutQueue(){
		return this.timeoutQueue;
	}
	
	TimeoutHashMap<MessageKey, Boolean> getDuplicateRemoteMap(){
		return this.duplicateRemoteMap;
	}
	
	Map<ChannelKey, CoapServerChannel> getServerChannels(){
		return this.serverChannels;
	}
	
	Map<ChannelKey, CoapClientChannel> getClientChannels(){
		return this.clientChannels;
	}
	
	WorkerThread getWorkerThread(){
		return this.workerThread;
	}
	
	
	public BasicCoapSocketHandler(CoapChannelManager channelManager) throws IOException {
		this(channelManager, 0);
	}

	private class ReceiveThread extends Thread {

		private Selector selector = null;
		private ByteBuffer dgramBuffer;
		private boolean MCThread;

		public ReceiveThread(boolean multicast) {
			this.dgramBuffer = ByteBuffer.allocate(CoapConstants.UDP_BUFFER_SIZE);
			this.MCThread = multicast;
			try {
				this.selector = Selector.open();
				BasicCoapSocketHandler.this.getDatagramChannel().register(this.selector, SelectionKey.OP_READ);
			} catch (IOException e1) {
			}
		}

		@Override
		public void run() {
			InetSocketAddress addr = null;
			DatagramPacket dgramPacket = new DatagramPacket(this.dgramBuffer.array(), CoapConstants.UDP_BUFFER_SIZE);

			if (this.MCThread) {

				while (BasicCoapSocketHandler.this.getDatagramSocket() != null) {
					this.dgramBuffer.clear();

					try {
						BasicCoapSocketHandler.this.getDatagramSocket().receive(dgramPacket);
						addr = new InetSocketAddress(dgramPacket.getAddress(), dgramPacket.getPort());
						this.dgramBuffer.position(dgramPacket.getLength());
						handleIncommingMessage(this.dgramBuffer, addr);
					} catch (IOException e2) {
					}
				}
			} else {
				while (BasicCoapSocketHandler.this.getDatagramChannel() != null) {

					/* handle incoming packets */
					this.dgramBuffer.clear();
					try {
						addr = (InetSocketAddress) BasicCoapSocketHandler.this.getDatagramChannel().receive(this.dgramBuffer);
					} catch (IOException e1) {
					}
					if (addr != null) {
						handleIncommingMessage(this.dgramBuffer, addr);
					}

					// Wait until new message is in the receive buffer of the socket
					try {
						this.selector.select(0);
					} catch (IOException e) {
					}
				}
			}
		}

		private boolean isHostDuplicate(int msgId) {
			if (BasicCoapSocketHandler.this.getDuplicateHostMap().get(msgId) != null) {
				return true;
			}
			return false;
		}

		private boolean isRemoteDuplicate(MessageKey msgKey) {
			if (BasicCoapSocketHandler.this.getDuplicateRemoteMap().get(msgKey) != null) {
				return true;
			}
			return false;
		}

		private void retransmitRemoteDuplicate(MessageKey msgKey) {
			CoapMessage retransMsg;
			retransMsg = BasicCoapSocketHandler.this.getRetransMsgMap().get(msgKey);
			if (retransMsg == null) {
			} else {
				BasicCoapSocketHandler.this.getWorkerThread().addMessageToSendBuffer(retransMsg);
			}
		}

		private void handleIncommingMessage(ByteBuffer buffer, InetSocketAddress addr) {
			CoapMessage msg;
			try {
				msg = AbstractCoapMessage.parseMessage(buffer.array(), buffer.position());
			} catch (Exception e) {
				return;
			}

			CoapPacketType packetType = msg.getPacketType();
			int msgId = msg.getMessageID();
			MessageKey msgKey = new MessageKey(msgId, addr.getAddress(), addr.getPort());

			if (msg.isRequest()) {
				/*
				 * --- INCOMING REQUEST: This is an incoming client request with
				 * a message key generated by the remote client
				 */
				if (packetType == CoapPacketType.ACK || packetType == CoapPacketType.RST) {
					return;
				}

				/*
				 * check for duplicates and retransmit the response if a
				 * duplication is detected
				 */
				if (isRemoteDuplicate(msgKey)) {
					retransmitRemoteDuplicate(msgKey);
					return;
				}

				/* find or create server channel and handle incoming message */
				CoapServerChannel channel = BasicCoapSocketHandler.this.getServerChannels()
						.get(new ChannelKey(addr.getAddress(), addr.getPort()));
				if (channel == null) {
					/* no server channel found -> create */
					channel = BasicCoapSocketHandler.this.getChannelManager()
							.createServerChannel(BasicCoapSocketHandler.this, msg, addr.getAddress(), addr.getPort());
					if (channel != null) {
						/* add the new channel to the channel map */
						addServerChannel(channel);
					} else {
						/*
						 * create failed -> server doesn't accept the connection
						 * --> send RST
						 */
						CoapChannel fakeChannel = new BasicCoapServerChannel(BasicCoapSocketHandler.this, null,
								addr.getAddress(), addr.getPort());
						CoapEmptyMessage rstMsg = new CoapEmptyMessage(CoapPacketType.RST, msgId);
						rstMsg.setChannel(fakeChannel);
						sendMessage(rstMsg);
						return;

					}
				}
				msg.setChannel(channel);
				channel.handleMessage(msg);
				return;

			} else if (msg.isResponse()) {
				/*
				 * --- INCOMING RESPONSE: This is an incoming server response
				 * (message ID generated by host) or a separate server response
				 * (message ID generated by remote)
				 */

				if (packetType == CoapPacketType.RST) {
					return;
				}

				/* check for separate response */
				if (packetType == CoapPacketType.CON) {
					/*
					 * This is a separate response, the message ID is generated
					 * by the remote
					 */
					if (isRemoteDuplicate(msgKey)) {
						retransmitRemoteDuplicate(msgKey);
						return;
					}
					/* This is a separate Response */
					CoapClientChannel channel = BasicCoapSocketHandler.this.getClientChannels()
							.get(new ChannelKey(addr.getAddress(), addr.getPort()));
					if (channel == null) {

						return;
					}
					msg.setChannel(channel);
					channel.handleMessage(msg);
					return;
				}

				/*
				 * normal response (ACK or NON), message id was generated by
				 * host
				 */
				if (isHostDuplicate(msgId)) {
					/* drop duplicate responses */
					return;
				}

				/* confirm the request */
				/*
				 * confirm message by removing it from the non confirmedMsgMap
				 */
				/*
				 * Corresponding to the spec the server should be aware of a NON
				 * as answer to a CON
				 */
				BasicCoapSocketHandler.this.getTimeoutConMsgMap().remove(msgId);
				CoapClientChannel channel = BasicCoapSocketHandler.this.getClientChannels()
						.get(new ChannelKey(addr.getAddress(), addr.getPort()));

				/*
				 * If no channel for the message can be found via channel key,
				 * it may be a multicast response! Check whether the message
				 * tokens of the last request and the current response match. If
				 * still no channel can be found, drop the message!
				 */
				if (channel == null) {
					boolean mcResp = false;
					Iterator<ChannelKey> it = BasicCoapSocketHandler.this.getClientChannels().keySet().iterator();
					while(it.hasNext()) {
						channel = BasicCoapSocketHandler.this.getClientChannels().get(it.next());
						try {
							if (new String(channel.getLastToken()).equals(new String(msg.getToken()))) {
								mcResp = true;
								break;
							}
						} catch (Exception e) {
						}
					}

					if (!mcResp) {
					} else if(null == channel){
					} else {
						msg.setChannel(channel);
						channel.handleMCResponse(msg, addr.getAddress(), addr.getPort());
					}
					return;
				}

				msg.setChannel(channel);
				channel.handleMessage(msg);
				return;

			} else {
				if (msg.isEmpty()) {
					if (packetType == CoapPacketType.CON || packetType == CoapPacketType.NON) {
						return;
					}

					/* ACK or RST, Message Id was generated by the host */
					if (isHostDuplicate(msgId)) {
						/* drop duplicate responses */
						return;
					}

					/* confirm */
					BasicCoapSocketHandler.this.getTimeoutConMsgMap().remove(msgId);

					/* get channel */
					/*
					 * This can be an ACK/RST for a client or a server channel
					 */
					CoapChannel channel = BasicCoapSocketHandler.this.getClientChannels()
							.get(new ChannelKey(addr.getAddress(), addr.getPort()));
					if (channel == null) {
						channel = BasicCoapSocketHandler.this.getServerChannels()
								.get(new ChannelKey(addr.getAddress(), addr.getPort()));
					}

					if (channel == null) {
						return;
					}

					msg.setChannel(channel);
					if (packetType == CoapPacketType.ACK) {
						/* separate response ACK */
						channel.handleMessage(msg);
						return;
					}

					if (packetType == CoapPacketType.RST) {
						/* connection closed by remote */
						channel.handleMessage(msg);
						return;
					}

				}
			}
		}
	}

	private class WorkerThread extends Thread {
		private Selector selector = null;
		private ConcurrentLinkedQueue<CoapMessage> workerSendBuffer = new ConcurrentLinkedQueue<CoapMessage>();

		public WorkerThread() {
			try {
				this.selector = Selector.open();
				/*
				 * No selection key is 0, because channel does not know, when
				 * new message are in sendBuffer anyway.
				 */
				BasicCoapSocketHandler.this.getDatagramChannel().register(this.selector, 0);
			} catch (IOException e1) {
			}
		}

		@Override
		public void run() {
			long waitFor = POLLING_INTERVALL;

			while (BasicCoapSocketHandler.this.getDatagramChannel() != null) {
				/* send all messages in the send buffer */
				sendBufferedMessages();

				waitFor = handleTimeouts();
				/*
				 * When sendBuffer is empty, wait until 1. selector.wakeup() is
				 * called by sendMessage() 2. timeout
				 */
				if (this.workerSendBuffer.isEmpty()) {
					try {
						this.selector.select(waitFor);
					} catch (IOException e) {
					}
				}
			}
		}

		synchronized void addMessageToSendBuffer(CoapMessage msg) {
			this.workerSendBuffer.add(msg);
			/* send immediately */
			this.selector.wakeup();
		}

		private void sendBufferedMessages() {
			CoapMessage msg = this.workerSendBuffer.poll();
			while (msg != null) {
				sendUdpMsg(msg);
				msg = this.workerSendBuffer.poll();
			}
		}

		private void sendUdpMsg(CoapMessage msg) {
			if (msg == null) {
				return;
			}

			CoapPacketType packetType = msg.getPacketType();
			InetAddress inetAddr = msg.getChannel().getRemoteAddress();
			int port = msg.getChannel().getRemotePort();
			int msgId = msg.getMessageID();

			if (packetType == CoapPacketType.CON) {
				/*
				 * in case of a CON this is a Request requests must be added to
				 * the timeout queue except this was the last retransmission
				 */
				if (msg.maxRetransReached()) {
					/* the connection is broken */
					BasicCoapSocketHandler.this.getTimeoutConMsgMap().remove(msgId);
					msg.getChannel().lostConnection(true, false);
					return;
				}
				msg.incRetransCounterAndTimeout();
				BasicCoapSocketHandler.this.getTimeoutConMsgMap().put(msgId, msg);
				TimeoutObject<Integer> tObj = new TimeoutObject<Integer>(msgId,
						msg.getTimeout() + System.currentTimeMillis());
				BasicCoapSocketHandler.this.getTimeoutQueue().add(tObj);
			}

			if (packetType == CoapPacketType.ACK || packetType == CoapPacketType.RST) {
				/* save this type of messages for a possible retransmission */
				BasicCoapSocketHandler.this.getRetransMsgMap().put(new MessageKey(msgId, inetAddr, port), msg);
			}

			/* Nothing to do for NON */

			/* send message */
			ByteBuffer buf = ByteBuffer.wrap(msg.serialize());
			try {
				BasicCoapSocketHandler.this.getDatagramChannel().send(buf, new InetSocketAddress(inetAddr, port));
			} catch (IOException e) {
			}
		}
	}

	private class MessageKey {
		private int msgID;
		private InetAddress inetAddr;
		private int port;

		public MessageKey(int msgID, InetAddress inetAddr, int port) {
			this.msgID = msgID;
			this.inetAddr = inetAddr;
			this.port = port;
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + getOuterType().hashCode();
			result = prime * result + ((this.inetAddr == null) ? 0 : this.inetAddr.hashCode());
			result = prime * result + this.msgID;
			result = prime * result + this.port;
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			MessageKey other = (MessageKey) obj;
			if (!getOuterType().equals(other.getOuterType()))
				return false;
			if (this.inetAddr == null) {
				if (other.inetAddr != null)
					return false;
			} else if (!this.inetAddr.equals(other.inetAddr))
				return false;
			if (this.msgID != other.msgID)
				return false;
			if (this.port != other.port)
				return false;
			return true;
		}

		private BasicCoapSocketHandler getOuterType() {
			return BasicCoapSocketHandler.this;
		}
	}

	private class TimeoutObject<T> implements Comparable<TimeoutObject<?>> {
		private long expires;
		private T object;

		public TimeoutObject(T object, long expires) {
			this.expires = expires;
			this.object = object;
		}

		public T getObject() {
			return this.object;
		}
		
		public long getExpire(){
			return this.expires;
		}

		public int compareTo(TimeoutObject<?> o) {
			return (int) (this.expires - o.expires);
		}
	}

	/**
	 * @return Milliseconds until the next timeout expires. POLLING_INTERVALL if
	 *         there is no timeout to wait for.
	 */
	long handleTimeouts() {
		long nextTimeout = POLLING_INTERVALL;

		while (true) {
			TimeoutObject<Integer> tObj;
			tObj = this.timeoutQueue.peek();
			if (tObj == null) {
				/* timeout queue is empty */
				nextTimeout = POLLING_INTERVALL;
				break;
			}

			nextTimeout = tObj.getExpire() - System.currentTimeMillis();
			if (nextTimeout > 0) {
				/* timeout not expired */
				break;
			}
			/*
			 * timeout expired, sendMessage will send the message and create a
			 * new timeout if the message was already confirmed,
			 * nonConfirmedMsgMap.get() will return null
			 */
			this.timeoutQueue.poll();
			Integer msgId = tObj.getObject();

			/* retransmit message after expired timeout */

			CoapMessage msg = null;
			msg = this.timeoutConMsgMap.get(msgId);
			if (msg != null)
				sendMessage(msg);
		}
		return nextTimeout;
	}

	private void addClientChannel(CoapClientChannel channel) {
		this.clientChannels.put(new ChannelKey(channel.getRemoteAddress(), channel.getRemotePort()), channel);
	}

	void addServerChannel(CoapServerChannel channel) {
		this.serverChannels.put(new ChannelKey(channel.getRemoteAddress(), channel.getRemotePort()), channel);
	}

	@Override
	public int getLocalPort() {
		return this.localPort;
	}

	@Override
	public void removeClientChannel(CoapClientChannel channel) {
		this.clientChannels.remove(new ChannelKey(channel.getRemoteAddress(), channel.getRemotePort()));
	}

	@Override
	public void removeServerChannel(CoapServerChannel channel) {
		this.serverChannels.remove(new ChannelKey(channel.getRemoteAddress(), channel.getRemotePort()));
	}

	@Override
	public void close() {
		if (BasicCoapSocketHandler.this.clientChannels != null)
			BasicCoapSocketHandler.this.clientChannels.clear();
		if (BasicCoapSocketHandler.this.serverChannels != null)
			BasicCoapSocketHandler.this.serverChannels.clear();

		try {
			BasicCoapSocketHandler.this.dgramChannel.close();
		} catch (IOException e) {
		}
		/* TODO: wake up threads (receive & worker) and kill them */
	}

	@Override
	public void sendMessage(CoapMessage message) {
		if (this.workerThread != null) {
			this.workerThread.addMessageToSendBuffer(message);
		}
	}

	@Override
	public CoapClientChannel connect(CoapClient client, InetAddress remoteAddress, int remotePort) {
		if (client == null) {
			return null;
		}

		if (this.clientChannels.containsKey(new ChannelKey(remoteAddress, remotePort))) {
			/* channel already exists */
			return null;
		}

		CoapClientChannel channel = new BasicCoapClientChannel(this, client, remoteAddress, remotePort);

		addClientChannel(channel);
		return channel;
	}

	@Override
	public CoapChannelManager getChannelManager() {
		return this.channelManager;
	}

}
